#!/data/data/com.termux/files/usr/bin/bash

#********************************************#
#                                           #
#  TermSyncTools v0.3.1                     #
#  A CLI tool to backup and restore termux  #
#  https://github.com/Noewolf5449/termux-sync #
#  By Johnny & Noe Fontaine                 #
#                                           #
#********************************************#

set -euo pipefail  # Strict mode pour une meilleure gestion des erreurs

# Variables globales
readonly SOURCE="$HOME"
readonly DEST="$HOME/storage/shared/Termux/Backup"
readonly PKGS_SRC="$PREFIX/var/log/apt/history.log"
readonly GDRIVE_REMOTE="Gdrive:/Termux/Backup"
readonly VERSION="0.3.1"
readonly TEMP_DIR="/data/data/com.termux/files/usr/tmp"
readonly PROGRAM_NAME=$(basename "$0")
readonly BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
readonly LOG_FILE="$TEMP_DIR/termsynctools.log"

# Couleurs et formatage
declare -r B='\e[1;34m'    # bleu
declare -r R='\e[1;31m'    # rouge
declare -r G='\e[1;32m'    # vert
declare -r W='\e[1;37m'    # blanc gras
declare -r Y='\e[1;33m'    # jaune
declare -r OFF='\e[0m'     # reset
declare -r T='       '     # tabulation
declare -r OK=" $W[$G ✓ $W]$OFF"
declare -r EXC=" $W[$Y • $W]$OFF"
declare -r ERR=" $W[$R ✗ $W]$OFF"

# Fonction de logging
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
}

# Gestion des erreurs améliorée
trap 'error_handler $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "::%s" ${FUNCNAME[@]:-})' ERR

error_handler() {
    local exit_code=$1
    local line_no=$2
    local bash_lineno=$3
    local last_cmd=$4
    local func_trace=$5
    
    log "ERROR" "Command '$last_cmd' failed with exit code $exit_code at line $line_no"
    printf "$ERR ${R}Erreur:${OFF} Commande échouée à la ligne $line_no\n" >&2
    
    # Nettoyage en cas d'erreur
    cleanup
    exit $exit_code
}

# Fonction de nettoyage
cleanup() {
    log "INFO" "Nettoyage des fichiers temporaires"
    rm -f "$TEMP_DIR"/*.tmp 2>/dev/null || true
}

# Vérification des dépendances
check_dependencies() {
    local deps=(tar pigz figlet lolcat rclone)
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            printf "$ERR ${R}Erreur:${OFF} $dep n'est pas installé.\n"
            printf "$T Installation en cours...\n"
            pkg install -y "$dep" || {
                log "ERROR" "Échec de l'installation de $dep"
                return 1
            }
        fi
    done
}

# Fonction de vérification d'espace disque
check_disk_space() {
    local required_space=$1  # en Mo
    local available_space=$(df -m "$DEST" | awk 'NR==2 {print $4}')
    
    if (( available_space < required_space )); then
        error "Espace disque insuffisant. Requis: ${required_space}Mo, Disponible: ${available_space}Mo"
        return 1
    fi
}

# Amélioration de la fonction backup_home
backup_home() {
    log "INFO" "Démarrage de la sauvegarde du home"
    info "Sauvegarde du home"
    printf "$T Veuillez patienter...\n"

    local temp_file="$TEMP_DIR/home_${BACKUP_DATE}.tmp"
    local backup_file="$DEST/home_${BACKUP_DATE}.bak"
    
    # Vérification de l'espace disque avant la sauvegarde
    local estimated_size=$(du -sm "$HOME" | cut -f1)
    check_disk_space $((estimated_size + 100)) || return 1

    # Liste des exclusions améliorée
    local exclude_file="$TEMP_DIR/exclude.txt"
    cat > "$exclude_file" << 'EOF'
.cache
storage
*/node_modules
*/venv
*/build
*/.git
*.log
*.tmp
EOF

    # Sauvegarde avec compression et vérification
    if tar --exclude-from="$exclude_file" -I 'pigz -9' -cf "$temp_file" -C "$SOURCE" . ; then
        mv "$temp_file" "$backup_file"
        
        # Vérification de l'intégrité
        if tar -tzf "$backup_file" &>/dev/null; then
            success "Home sauvegardé dans: $backup_file"
            log "INFO" "Sauvegarde du home réussie: $backup_file"
            
            # Calcul et affichage de la taille
            local backup_size=$(du -h "$backup_file" | cut -f1)
            printf "$T Taille de la sauvegarde: $backup_size\n"
            
            sync_with_cloud "up" "$(basename "$backup_file")" "$cloud_service"
            return 0
        else
            error "Erreur d'intégrité de la sauvegarde"
            rm -f "$backup_file"
            return 1
        fi
    else
        rm -f "$temp_file"
        error "Échec de la sauvegarde du home"
        return 1
    fi
}

# [Le reste des fonctions suit le même modèle d'amélioration...]

# Fonction principale améliorée
main() {
    # Vérification des privilèges et de l'environnement
    if [[ $EUID -eq 0 ]]; then
        error "Ce script ne doit pas être exécuté en tant que root"
        exit 1
    }
    
    # Initialisation du fichier de log
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE"
    
    log "INFO" "Démarrage de TermSyncTools v$VERSION"
    
    # Vérification des dépendances
    check_dependencies || exit 1
    
    # Initialisation de l'environnement
    init_environment || exit 1
    
    # Affichage du banner
    display_banner
    
    # Traitement des arguments
    case "${1:-}" in
        -h|--help)
            show_help
            ;;
        -v|--version)
            show_version
            ;;
        -b|--backup)
            local backup_type=${2:-}
            case "$backup_type" in
                home|pkgs)
                    "backup_$backup_type"
                    ;;
                *)
                    error "Type de sauvegarde invalide"
                    show_help
                    exit 1
                    ;;
            esac
            ;;
        # [Autres cas...]
        *)
            error "Action invalide"
            show_help
            exit 1
            ;;
    esac
}

# Démarrage du script
main "$@"
cleanup
exit 0
