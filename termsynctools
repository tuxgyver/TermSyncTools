#!/data/data/com.termux/files/usr/bin/bash

#********************************************#
#                                           #
#  TermSyncTools v0.3.0                     #
#  A CLI tool to backup and restore termux  #
#  https://github.com/Noewolf5449/termux-sync #
#  By Johnny & Noe Fontaine                 #
#                                           #
#********************************************#

# Variables
readonly SOURCE="$HOME"
readonly DEST="$HOME/storage/shared/Termux/Backup"
readonly PKGS_SRC="$PREFIX/var/log/apt/history.log"
readonly GDRIVE_REMOTE="Gdrive:/Termux/Backup"
readonly VERSION="0.3.0"
readonly TEMP_DIR="/data/data/com.termux/files/usr/tmp"
readonly program_name=$(basename "$0")

# Colors
B='\e[1;34m'    # blue
R='\e[1;31m'    # red
G='\e[1;32m'    # green
W='\e[1;37m'    # white bold
Y='\e[1;33m'    # yellow
off='\e[0m'     # reset color
t='       '     # tab
OK=" $W[$G ‚úì $W]$off"
EXC=" $W[$Y ‚Ä¢ $W]$off"
ERR=" $W[$R ‚úó $W]$off"

# Color Table
show_color_table() {
    printf "$W Table des couleurs:\n"
    printf "${R}Red: ${R}Ceci est du texte rouge$off\n"
    printf "${G}Green: ${G}Ceci est du texte vert$off\n"
    printf "${Y}Yellow: ${Y}Ceci est du texte jaune$off\n"
    printf "${B}Blue: ${B}Ceci est du texte bleu$off\n"
    printf "${W}White: ${W}Ceci est du texte blanc$off\n"
}

# Initialize environment
init_environment() {
    # V√©rifier/cr√©er le r√©pertoire temporaire
    if [[ ! -d "$TEMP_DIR" ]]; then
        mkdir -p "$TEMP_DIR"
        chmod 700 "$TEMP_DIR"
    fi
    # V√©rifier/cr√©er le r√©pertoire de destination
    if [[ ! -d "$DEST" ]]; then
        mkdir -p "$DEST"
    fi
    # V√©rifier les permissions de stockage
    while ! [ -w /storage/emulated/0/ ]; do
        printf "$ERR Autorisez l'acc√®s au stockage$off\n"
        termux-setup-storage
        sleep 2
    done
}

# Banner
display_banner() {
    figlet "TermSyncTools" | lolcat -i
    printf "\n\n"
}

# Help
show_help() {
    printf "${W}Usage: ${G}$program_name${off} [-hv] [-b|-r [home|pkgs]] [-c] [-s cloud_service] [-d] [-u]\n"
    printf "${W}-h${off}               ${G}affiche cette aide${off}\n"
    printf "${W}-v${off}               ${G}affiche la version${off}\n"
    printf "${W}-b [home|pkgs]${off}   ${G}sauvegarde home et/ou packages${off}\n"
    printf "${W}-r [home|pkgs]${off}   ${G}restaure home et/ou packages${off}\n"
    printf "${W}-c${off}               ${G}configure les sauvegardes automatiques avec cron${off}\n"
    printf "${W}-s cloud_service${off}  ${G}s√©lectionne le service cloud (google, dropbox, onedrive, s3)${off}\n"
    printf "${W}-d${off}               ${G}supprime les sauvegardes${off}\n"
    printf "${W}-u${off}               ${G}d√©sinstalle les t√¢ches cron existantes${off}\n"
}

# Version
show_version() {
    printf "TermSyncTools version $VERSION\n"
    printf "Outil de sauvegarde et restauration pour Termux\n"
    printf "https://github.com/Noewolf5449/termux-sync\n"
    printf "By Fontaine Johnny et No√© üòâ"
}

# Error handling
error() {
    printf "$ERR $R Erreur:$off $*\n" >&2
}

# Success message
success() {
    printf "$OK $*\n"
}

# Info message
info() {
    printf "$EXC $*\n"
}

# Check Internet
check_internet() {
    if ping -q -w 1 -c 1 8.8.8.8 &> /dev/null; then
        return 0
    fi
    return 1
}

# Sync with cloud service
sync_with_cloud() {
    local direction=$1
    local file=$2
    local service=$3

    info "Synchronisation avec $service..."

    if ! rclone listremotes | grep -q "$service:"; then
        error "$service non configur√©. Ex√©cutez 'rclone config'"
        return 1
    fi

    case "$direction" in
        "up")
            if [[ -n "$file" && -f "$DEST/$file" ]]; then
                if rclone copy "$DEST/$file" "$service:/Termux/Backup" --progress; then
                    success "Synchronisation termin√©e"
                    return 0
                fi
            fi
            ;;
        "down")
            if rclone sync "$service:/Termux/Backup" "$DEST" --progress; then
                success "Synchronisation termin√©e"
                return 0
            fi
            ;;
        *)
            error "Direction de synchronisation invalide"
            return 1
            ;;
    esac

    error "√âchec de la synchronisation"
    return 1
}

# Backup home
backup_home() {
    info "Sauvegarde du home"
    printf "$t Veuillez patienter...\n"

    local temp_file="$TEMP_DIR/${backup_name}_home.tmp"
    local backup_file="$DEST/${backup_name}_home.bak"

    # Liste des exclusions
    local exclude_dirs=(
        ".cache"
        "storage"
        "*/node_modules"
        "*/venv"
        "$TEMP_DIR"
        "$DEST"
    )

    local exclude_args=""
    for dir in "${exclude_dirs[@]}"; do
        exclude_args+="--exclude='$dir' "
    done

    # Sauvegarde
    if eval tar -I pigz -cf "$temp_file" -C "$SOURCE" $exclude_args . ; then
        mv "$temp_file" "$backup_file"
        success "Home sauvegard√© dans: $backup_file"
        sync_with_cloud "up" "${backup_name}_home.bak" "$cloud_service"
        return 0
    else
        rm -f "$temp_file"
        error "√âchec de la sauvegarde du home"
        return 1
    fi
}

# Backup packages
backup_pkgs() {
    info "Sauvegarde des packages"
    printf "$t Veuillez patienter...\n"

    local pkg_file="$DEST/${backup_name}_pkgs.bak"

    # Liste des packages install√©s
    if dpkg --get-selections | grep -v deinstall | cut -f1 > "$pkg_file"; then
        success "Packages sauvegard√©s dans: $pkg_file"
        sync_with_cloud "up" "${backup_name}_pkgs.bak" "$cloud_service"
        return 0
    else
        error "√âchec de la sauvegarde des packages"
        return 1
    fi
}

# Restore home
restore_home() {
    info "Restauration du home"
    printf "$t Veuillez patienter...\n"

    # Synchronisation avec le service cloud
    sync_with_cloud "down" "" "$cloud_service"

    # V√©rifie les sauvegardes disponibles
    local backups=($(ls -1 "$DEST"/*_home.bak 2>/dev/null))
    if [ ${#backups[@]} -eq 0 ]; then
        error "Aucune sauvegarde disponible"
        return 1
    fi

    # Liste les sauvegardes avec la date de cr√©ation
    printf "\n$t Sauvegardes disponibles:\n"
    for i in "${!backups[@]}"; do
        local creation_date=$(stat -c %y "${backups[$i]}")
        printf "$t $((i+1)). ${backups[$i]##*/} ($creation_date)\n"
    done
    printf "\n"

    # S√©lection de la sauvegarde
    local backup_number
    read -p "Num√©ro de la sauvegarde √† restaurer: " backup_number

    if ! [[ "$backup_number" =~ ^[0-9]+$ ]] || [ "$backup_number" -lt 1 ] || [ "$backup_number" -gt ${#backups[@]} ]; then
        error "S√©lection invalide"
        return 1
    fi

    local selected_backup="${backups[$((backup_number-1))]}"
    local safety_backup="$TEMP_DIR/home_backup_before_restore_$(date +%Y%m%d_%H%M%S).bak"

    # Cr√©e une sauvegarde de s√©curit√©
    info "Cr√©ation d'une sauvegarde de s√©curit√©..."
    if ! tar -I pigz -cf "$safety_backup" -C "$SOURCE" . ; then
        error "Impossible de cr√©er la sauvegarde de s√©curit√©"
        return 1
    fi

    # Restaure la sauvegarde
    info "Restauration en cours..."
    if tar -I pigz -xf "$selected_backup" -C "$SOURCE"; then
        success "Home restaur√© avec succ√®s"
        printf "$t Red√©marrez votre session pour appliquer les changements\n"
        rm -f "$safety_backup"
        return 0
    else
        error "√âchec de la restauration"
        info "Restauration de la sauvegarde de s√©curit√©..."
        tar -I pigz -xf "$safety_backup" -C "$SOURCE"
        rm -f "$safety_backup"
        return 1
    fi
}

# Restore packages
restore_pkgs() {
    if ! check_internet; then
        error "Pas de connexion internet"
        return 1
    fi

    info "Restauration des packages"
    printf "$t Veuillez patienter...\n"

    # Synchronisation avec le service cloud
    sync_with_cloud "down" "" "$cloud_service"

    # V√©rifie les sauvegardes disponibles
    local backups=($(ls -1 "$DEST"/*_pkgs.bak 2>/dev/null))
    if [ ${#backups[@]} -eq 0 ]; then
        error "Aucune sauvegarde disponible"
        return 1
    fi

    # Liste les sauvegardes avec la date de cr√©ation
    printf "\n$t Sauvegardes disponibles:\n"
    for i in "${!backups[@]}"; do
        local creation_date=$(stat -c %y "${backups[$i]}")
        printf "$t $((i+1)). ${backups[$i]##*/} ($creation_date)\n"
    done
    printf "\n"

    # S√©lection de la sauvegarde
    local backup_number
    read -p "Num√©ro de la sauvegarde √† restaurer: " backup_number

    if ! [[ "$backup_number" =~ ^[0-9]+$ ]] || [ "$backup_number" -lt 1 ] || [ "$backup_number" -gt ${#backups[@]} ]; then
        error "S√©lection invalide"
        return 1
    fi

    local selected_backup="${backups[$((backup_number-1))]}"

    # Mise √† jour et installation des packages
    if apt-get update && apt-get install -y $(cat "$selected_backup"); then
        success "Packages restaur√©s"
        printf "$t Red√©marrez votre session pour appliquer les changements\n"
        return 0
    else
        error "√âchec de la restauration des packages"
        return 1
    fi
}

# Delete backups
delete_backups() {
    info "Suppression des sauvegardes..."

    # V√©rifie les sauvegardes disponibles
    local backups=($(ls -1 "$DEST"/*.bak 2>/dev/null))
    if [ ${#backups[@]} -eq 0 ]; then
        error "Aucune sauvegarde disponible"
        return 1
    fi

    # Liste les sauvegardes avec la date de cr√©ation
    printf "\n$t Sauvegardes disponibles:\n"
    for i in "${!backups[@]}"; do
        local creation_date=$(stat -c %y "${backups[$i]}")
        printf "$t $((i+1)). ${backups[$i]##*/} ($creation_date)\n"
    done
    printf "\n"

    # S√©lection de la sauvegarde √† supprimer
    local backup_number
    read -p "Num√©ro de la sauvegarde √† supprimer: " backup_number

    if ! [[ "$backup_number" =~ ^[0-9]+$ ]] || [ "$backup_number" -lt 1 ] || [ "$backup_number" -gt ${#backups[@]} ]; then
        error "S√©lection invalide"
        return 1
    fi

    local selected_backup="${backups[$((backup_number-1))]}"

    # Suppression de la sauvegarde
    info "Suppression de la sauvegarde en cours..."
    if rm -f "$selected_backup"; then
        success "Sauvegarde supprim√©e avec succ√®s"
        return 0
    else
        error "√âchec de la suppression de la sauvegarde"
        return 1
    fi
}

# Unschedule cron jobs
unschedule_cron() {
    info "D√©sinstallation des t√¢ches cron existantes..."

    # Liste les t√¢ches cron existantes
    local cron_jobs=$(crontab -l 2>/dev/null)
    if [[ -z "$cron_jobs" ]]; then
        error "Aucune t√¢che cron existante"
        return 1
    fi

    # Affiche les t√¢ches cron existantes
    printf "\n$t T√¢ches cron existantes:\n"
    local job_number=1
    while IFS= read -r line; do
        printf "$t $((job_number++)) $line\n"
    done <<< "$cron_jobs"

    # S√©lection de la t√¢che √† supprimer
    local job_to_delete
    read -p "Num√©ro de la t√¢che √† supprimer: " job_to_delete

    if ! [[ "$job_to_delete" =~ ^[0-9]+$ ]] || [ "$job_to_delete" -lt 1 ] || [ "$job_to_delete" -gt $job_number ]; then
        error "S√©lection invalide"
        return 1
    fi

    # Suppression de la t√¢che cron
    local new_cron_jobs=()
    job_number=1
    while IFS= read -r line; do
        if [ "$job_number" -ne "$job_to_delete" ]; then
            new_cron_jobs+=("$line")
        fi
        job_number=$((job_number + 1))
    done <<< "$cron_jobs"

    # Mise √† jour des t√¢ches cron
    printf "%s\n" "${new_cron_jobs[@]}" | crontab -
    success "T√¢che cron supprim√©e avec succ√®s"
}

# Main function
main() {
    init_environment
    display_banner

    local action=$1
    shift

    case "$action" in
        -h|--help)
            show_help
            ;;
        -v|--version)
            show_version
            ;;
        -b|--backup)
            local backup_type=$1
            shift
            case "$backup_type" in
                home)
                    backup_home
                    ;;
                pkgs)
                    backup_pkgs
                    ;;
                *)
                    error "Type de sauvegarde invalide"
                    show_help
                    ;;
            esac
            ;;
        -r|--restore)
            local restore_type=$1
            shift
            case "$restore_type" in
                home)
                    restore_home
                    ;;
                pkgs)
                    restore_pkgs
                    ;;
                *)
                    error "Type de restauration invalide"
                    show_help
                    ;;
            esac
            ;;
        -c|--cron)
            # Configure cron jobs
            ;;
        -s|--sync)
            local cloud_service=$1
            shift
            case "$cloud_service" in
                google|dropbox|onedrive|s3)
                    ;;
                *)
                    error "Service cloud non support√©"
                    show_help
                    ;;
            esac
            ;;
        -d|--delete)
            delete_backups
            ;;
        -u|--unschedule)
            unschedule_cron
            ;;
        *)
            error "Action invalide"
            show_help
            ;;
    esac
}

main "$@"
exit $?
